/*
 * Wazuh Vulnerability scanner - Scan Orchestrator
 * Copyright (C) 2015, Wazuh Inc.
 * March 25, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _SCAN_CONTEXT_HPP
#define _SCAN_CONTEXT_HPP

#include "external/nlohmann/json.hpp"
#include "flatbuffers/include/syscollector_deltas_generated.h"
#include "flatbuffers/include/syscollector_synchronization_generated.h"
#include "logging_helper.h"
#include <functional>
#include <memory>
#include <string>
#include <variant>
#include <vector>

enum class MessageType
{
    Unknown = 0,
    Delta = 1,
    Sync = 2,
};

enum class ScannerType
{
    Unknown = 0,
    PackageInsert = 1,
    PackageDelete = 2,
    Os = 3,
    HotfixInsert = 4,
    HotfixDelete = 5,
};

enum class OperationType
{
    Unknown = 0,
    Insert = 1,
    Delete = 2,
};

/**
 * @brief ScanContext structure.
 *
 */
struct ScanContext final
{
private:
    // LCOV_EXCL_START
    /**
     * @brief Extract data.
     * @tparam T Type of data.
     * @param func Function to extract data from delta.
     * @param func2 Function to extract data from sync message.
     *
     * @return Data.
     */
    template<typename T>
    T extractData(std::function<T(const SyscollectorDeltas::Delta*)> func,
                  std::function<T(const SyscollectorSynchronization::SyncMsg*)> func2) const
    {
        if (m_messageType == MessageType::Delta)
        {
            auto delta = std::get<const SyscollectorDeltas::Delta*>(m_data);
            return func(delta);
        }
        else if (m_messageType == MessageType::Sync)
        {
            auto syncMsg = std::get<const SyscollectorSynchronization::SyncMsg*>(m_data);
            return func2(syncMsg);
        }
        else
        {
            throw std::runtime_error("Unknown type.");
        }
    }

public:
    ScanContext() = default;
    /**
     * @brief Class constructor.
     *
     * @param data Scan context.
     */
    explicit ScanContext(
        std::variant<const SyscollectorDeltas::Delta*, const SyscollectorSynchronization::SyncMsg*>& data)
    {
        std::visit(
            [this](auto&& arg)
            {
                using T = std::decay_t<decltype(arg)>;
                if constexpr (std::is_same_v<T, const SyscollectorDeltas::Delta*>)
                {
                    m_data = arg;
                    m_messageType = MessageType::Delta;
                    auto delta = std::get<const SyscollectorDeltas::Delta*>(m_data);

                    if (delta->operation())
                    {
                        if (delta->data_type() == SyscollectorDeltas::Provider_dbsync_packages)
                        {
                            // Modify events not exist for packages, because all fields that change in an update are PK.
                            if (delta->operation()->str().compare("INSERTED") == 0)
                            {
                                m_type = ScannerType::PackageInsert;
                                m_operationType = OperationType::Insert;
                            }
                            else if (delta->operation()->str().compare("DELETED") == 0)
                            {
                                m_type = ScannerType::PackageDelete;
                                m_operationType = OperationType::Delete;
                            }
                        }
                        else if (delta->data_type() == SyscollectorDeltas::Provider_dbsync_osinfo)
                        {
                            m_type = ScannerType::Os;
                            m_operationType = OperationType::Insert;
                        }
                        else if (delta->data_type() == SyscollectorDeltas::Provider_dbsync_hotfixes)
                        {
                            if (delta->operation()->str().compare("INSERTED") == 0)
                            {
                                m_type = ScannerType::HotfixInsert;
                                m_operationType = OperationType::Insert;
                            }
                            else if (delta->operation()->str().compare("DELETED") == 0)
                            {
                                m_type = ScannerType::HotfixDelete;
                                m_operationType = OperationType::Delete;
                            }
                        }
                    }
                    else
                    {
                        throw std::runtime_error("Operation not found in delta.");
                    }
                }
                else if constexpr (std::is_same_v<T, const SyscollectorSynchronization::SyncMsg*>)
                {
                    m_data = arg;
                    m_messageType = MessageType::Sync;
                    auto syncMsg = std::get<const SyscollectorSynchronization::SyncMsg*>(m_data);

                    if (syncMsg->data_type() == SyscollectorSynchronization::DataUnion_state)
                    {
                        if (syncMsg->data_as_state()->attributes_type() ==
                            SyscollectorSynchronization::AttributesUnion_syscollector_osinfo)
                        {
                            m_type = ScannerType::Os;
                            m_operationType = OperationType::Insert;
                        }
                        else if (syncMsg->data_as_state()->attributes_type() ==
                                 SyscollectorSynchronization::AttributesUnion_syscollector_packages)
                        {
                            m_type = ScannerType::PackageInsert;
                            m_operationType = OperationType::Insert;
                        }
                        else if (syncMsg->data_as_state()->attributes_type() ==
                                 SyscollectorSynchronization::AttributesUnion_syscollector_hotfixes)
                        {
                            m_type = ScannerType::HotfixInsert;
                            m_operationType = OperationType::Insert;
                        }
                    }
                    else
                    {
                        throw std::runtime_error("Data type not found in sync message.");
                    }
                }
                else
                {
                    throw std::runtime_error("Unknown type.");
                }
            },
            data);
    }

    /**
     * @brief Gets scan type.
     *
     * @return Scan type.
     */
    ScannerType getType() const
    {
        return m_type;
    }

    /**
     * @brief Gets package name.
     * @return Package name.
     */
    std::string_view packageName() const
    {
        return extractData<std::string_view>(
            [](const SyscollectorDeltas::Delta* delta) {
                return delta->data_as_dbsync_packages()->name() ? delta->data_as_dbsync_packages()->name()->c_str()
                                                                : "";
            },
            [](const SyscollectorSynchronization::SyncMsg* syncMsg)
            {
                return syncMsg->data_as_state()->attributes_as_syscollector_packages()->name()
                           ? syncMsg->data_as_state()->attributes_as_syscollector_packages()->name()->c_str()
                           : "";
            });
    }

    /**
     * @brief Gets package version.
     * @return Package version.
     */
    std::string_view packageVersion() const
    {
        return extractData<std::string_view>(
            [](const SyscollectorDeltas::Delta* delta) {
                return delta->data_as_dbsync_packages()->version()
                           ? delta->data_as_dbsync_packages()->version()->c_str()
                           : "";
            },
            [](const SyscollectorSynchronization::SyncMsg* syncMsg)
            {
                return syncMsg->data_as_state()->attributes_as_syscollector_packages()->version()
                           ? syncMsg->data_as_state()->attributes_as_syscollector_packages()->version()->c_str()
                           : "";
            });
    }

    /**
     * @brief Gets vendor name.
     * @return Vendor name.
     */
    std::string_view packageVendor() const
    {
        return extractData<std::string_view>(
            [](const SyscollectorDeltas::Delta* delta) {
                return delta->data_as_dbsync_packages()->vendor() ? delta->data_as_dbsync_packages()->vendor()->c_str()
                                                                  : "";
            },
            [](const SyscollectorSynchronization::SyncMsg* syncMsg)
            {
                return syncMsg->data_as_state()->attributes_as_syscollector_packages()->vendor()
                           ? syncMsg->data_as_state()->attributes_as_syscollector_packages()->vendor()->c_str()
                           : "";
            });
    }

    /**
     * @brief Gets package install time.
     * @return Package install time.
     */
    std::string_view packageInstallTime() const
    {
        return extractData<std::string_view>(
            [](const SyscollectorDeltas::Delta* delta)
            {
                return delta->data_as_dbsync_packages()->install_time()
                           ? delta->data_as_dbsync_packages()->install_time()->c_str()
                           : "";
            },
            [](const SyscollectorSynchronization::SyncMsg* syncMsg)
            {
                return syncMsg->data_as_state()->attributes_as_syscollector_packages()->install_time()
                           ? syncMsg->data_as_state()->attributes_as_syscollector_packages()->install_time()->c_str()
                           : "";
            });
    }

    /**
     * @brief Gets package location.
     * @return Package location.
     */
    std::string_view packageLocation() const
    {
        return extractData<std::string_view>(
            [](const SyscollectorDeltas::Delta* delta) {
                return delta->data_as_dbsync_packages()->location()
                           ? delta->data_as_dbsync_packages()->location()->c_str()
                           : "";
            },
            [](const SyscollectorSynchronization::SyncMsg* syncMsg)
            {
                return syncMsg->data_as_state()->attributes_as_syscollector_packages()->location()
                           ? syncMsg->data_as_state()->attributes_as_syscollector_packages()->location()->c_str()
                           : "";
            });
    }

    /**
     * @brief Gets package architecture.
     * @return Package architecture.
     */
    std::string_view packageArchitecture() const
    {
        return extractData<std::string_view>(
            [](const SyscollectorDeltas::Delta* delta)
            {
                return delta->data_as_dbsync_packages()->architecture()
                           ? delta->data_as_dbsync_packages()->architecture()->c_str()
                           : "";
            },
            [](const SyscollectorSynchronization::SyncMsg* syncMsg)
            {
                return syncMsg->data_as_state()->attributes_as_syscollector_packages()->architecture()
                           ? syncMsg->data_as_state()->attributes_as_syscollector_packages()->architecture()->c_str()
                           : "";
            });
    }

    /**
     * @brief Gets package groups.
     * @return Package groups.
     */
    std::string_view packageGroups() const
    {
        return extractData<std::string_view>(
            [](const SyscollectorDeltas::Delta* delta) {
                return delta->data_as_dbsync_packages()->groups() ? delta->data_as_dbsync_packages()->groups()->c_str()
                                                                  : "";
            },
            [](const SyscollectorSynchronization::SyncMsg* syncMsg)
            {
                return syncMsg->data_as_state()->attributes_as_syscollector_packages()->groups()
                           ? syncMsg->data_as_state()->attributes_as_syscollector_packages()->groups()->c_str()
                           : "";
            });
    }

    /**
     * @brief Gets package description
     * @return Package description.
     */
    std::string_view packageDescription() const
    {
        return extractData<std::string_view>(
            [](const SyscollectorDeltas::Delta* delta)
            {
                return delta->data_as_dbsync_packages()->description()
                           ? delta->data_as_dbsync_packages()->description()->c_str()
                           : "";
            },
            [](const SyscollectorSynchronization::SyncMsg* syncMsg)
            {
                return syncMsg->data_as_state()->attributes_as_syscollector_packages()->description()
                           ? syncMsg->data_as_state()->attributes_as_syscollector_packages()->description()->c_str()
                           : "";
            });
    }

    /**
     * @brief Gets package size.
     * @return Package size.
     */
    uint64_t packageSize() const
    {
        return extractData<uint64_t>(
            [](const SyscollectorDeltas::Delta* delta) { return delta->data_as_dbsync_packages()->size(); },
            [](const SyscollectorSynchronization::SyncMsg* syncMsg)
            { return syncMsg->data_as_state()->attributes_as_syscollector_packages()->size(); });
    }

    /**
     * @brief Gets package priority.
     * @return Package priority.
     */
    std::string_view packagePriority() const
    {
        return extractData<std::string_view>(
            [](const SyscollectorDeltas::Delta* delta) {
                return delta->data_as_dbsync_packages()->priority()
                           ? delta->data_as_dbsync_packages()->priority()->c_str()
                           : "";
            },
            [](const SyscollectorSynchronization::SyncMsg* syncMsg)
            {
                return syncMsg->data_as_state()->attributes_as_syscollector_packages()->priority()
                           ? syncMsg->data_as_state()->attributes_as_syscollector_packages()->priority()->c_str()
                           : "";
            });
    }

    /**
     * @brief Gets package multi arch.
     * @return Package multi arch.
     */
    std::string_view packageMultiarch() const
    {
        return extractData<std::string_view>(
            [](const SyscollectorDeltas::Delta* delta) {
                return delta->data_as_dbsync_packages()->multiarch()
                           ? delta->data_as_dbsync_packages()->multiarch()->c_str()
                           : "";
            },
            [](const SyscollectorSynchronization::SyncMsg* syncMsg)
            {
                return syncMsg->data_as_state()->attributes_as_syscollector_packages()->multiarch()
                           ? syncMsg->data_as_state()->attributes_as_syscollector_packages()->multiarch()->c_str()
                           : "";
            });
    }

    /**
     * @brief Gets package source
     * @return Package source.
     */
    std::string_view packageSource() const
    {
        return extractData<std::string_view>(
            [](const SyscollectorDeltas::Delta* delta) {
                return delta->data_as_dbsync_packages()->source() ? delta->data_as_dbsync_packages()->source()->c_str()
                                                                  : "";
            },
            [](const SyscollectorSynchronization::SyncMsg* syncMsg)
            {
                return syncMsg->data_as_state()->attributes_as_syscollector_packages()->source()
                           ? syncMsg->data_as_state()->attributes_as_syscollector_packages()->source()->c_str()
                           : "";
            });
    }

    /**
     * @brief Gets package format.
     * @return Package format.
     */
    std::string_view packageFormat() const
    {
        return extractData<std::string_view>(
            [](const SyscollectorDeltas::Delta* delta) {
                return delta->data_as_dbsync_packages()->format() ? delta->data_as_dbsync_packages()->format()->c_str()
                                                                  : "";
            },
            [](const SyscollectorSynchronization::SyncMsg* syncMsg)
            {
                return syncMsg->data_as_state()->attributes_as_syscollector_packages()->format()
                           ? syncMsg->data_as_state()->attributes_as_syscollector_packages()->format()->c_str()
                           : "";
            });
    }

    /**
     * @brief Gets package id.
     * @return Package id.
     */
    std::string_view packageItemId() const
    {
        return extractData<std::string_view>(
            [](const SyscollectorDeltas::Delta* delta) {
                return delta->data_as_dbsync_packages()->item_id()
                           ? delta->data_as_dbsync_packages()->item_id()->c_str()
                           : "";
            },
            [](const SyscollectorSynchronization::SyncMsg* syncMsg)
            {
                return syncMsg->data_as_state()->attributes_as_syscollector_packages()->item_id()
                           ? syncMsg->data_as_state()->attributes_as_syscollector_packages()->item_id()->c_str()
                           : "";
            });
    }

    /**
     * @brief Gets agent id.
     * @return Agent id.
     */
    std::string_view agentId() const
    {
        return extractData<std::string_view>(
            [](const SyscollectorDeltas::Delta* delta)
            { return delta->agent_info()->agent_id() ? delta->agent_info()->agent_id()->c_str() : ""; },
            [](const SyscollectorSynchronization::SyncMsg* syncMsg)
            { return syncMsg->agent_info()->agent_id() ? syncMsg->agent_info()->agent_id()->c_str() : ""; });
    }

    /**
     * @brief Gets agent IP.
     *
     * @return Agent IP.
     */
    std::string_view agentIp() const
    {
        return extractData<std::string_view>(
            [](const SyscollectorDeltas::Delta* delta)
            { return delta->agent_info()->agent_ip() ? delta->agent_info()->agent_ip()->c_str() : ""; },
            [](const SyscollectorSynchronization::SyncMsg* syncMsg)
            { return syncMsg->agent_info()->agent_ip() ? syncMsg->agent_info()->agent_ip()->c_str() : ""; });
    }

    /**
     * @brief Gets agent name.
     *
     * @return Agent name.
     */
    std::string_view agentName() const
    {
        return extractData<std::string_view>(
            [](const SyscollectorDeltas::Delta* delta)
            { return delta->agent_info()->agent_name() ? delta->agent_info()->agent_name()->c_str() : ""; },
            [](const SyscollectorSynchronization::SyncMsg* syncMsg)
            { return syncMsg->agent_info()->agent_name() ? syncMsg->agent_info()->agent_name()->c_str() : ""; });
    }

    /**
     * @brief Gets agent node name.
     * @return Agent node name.
     */
    std::string_view agentNodeName() const
    {
        return extractData<std::string_view>(
            [](const SyscollectorDeltas::Delta* delta)
            { return delta->agent_info()->node_name() ? delta->agent_info()->node_name()->c_str() : ""; },
            [](const SyscollectorSynchronization::SyncMsg* syncMsg)
            { return syncMsg->agent_info()->node_name() ? syncMsg->agent_info()->node_name()->c_str() : ""; });
    }

    /**
     * @brief Gets operation type.
     * @return Operation type.
     */
    OperationType operationType() const
    {
        return m_operationType;
    }

    /**
     * @brief Class destructor.
     *
     */
    ~ScanContext() = default;

    /**
     * @brief Elements to process.
     */
    std::unordered_map<std::string, nlohmann::json> m_elements;
    // LCOV_EXCL_STOP
private:
    /**
     * @brief Operation type.
     */
    OperationType m_operationType = OperationType::Unknown;

    /**
     * @brief Scan type.
     *
     */
    ScannerType m_type = ScannerType::Unknown;

    /**
     * @brief Message type.
     * @details Delta or Sync message.
     */
    MessageType m_messageType = MessageType::Unknown;

    /**
     * @brief Scan context.
     *
     */
    std::variant<const SyscollectorDeltas::Delta*, const SyscollectorSynchronization::SyncMsg*> m_data;

    // LCOV_EXCL_STOP
};

#endif // _SCAN_CONTEXT_HPP
